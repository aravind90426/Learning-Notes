   
            0   1   2   3  4   5    6   7  8   9
    arr = [ 2 , 4 , 6 , 9 ,11 ,12 ,14, 20 ,36 ,48]

    target  = 36

    1)   FIND THE MIDDLE element
     
    2)    target > mid =>   search in the right else search in the left

    3)    if middle element == target element     // ans

    

            0   1   2   3  4   5    6   7  8   9
    arr = [ 2 , 4 , 6 , 9 ,11 ,12 ,14, 20 ,36 ,48]
                           __
    target  = 14

      mid=  11      11<36


       5    6   7  8   9
     [ 12 ,14, 20 ,36 ,48]
               __

    target  = 36
       mid = 20
     
        mid>14



      5   6
    [12, 14 ]

     mid =12

       mid<target


        6
       [14]

    target == arr[mid]
     
    return mid

0--------------------------0
  
 if   s>e  :  element not found.

  time   |
         |
         |
         |______________
         |
         |______________> size

         Best case
         
         O(1) one comparison only

-----------------------------------------

why binary search ????

 find the max number of comparison in worst case

                 ____________________________
                 |_____________|_/__/__/__/_|   N      N/2^0

   1st level                   |_____|_/__/_|   N/2    N/2^1

                                     |__|_/_|   N/2/2  = N/4    = N/2^2
  2nd level
    
   3rd level                             |__|    N/8            = N/2^3

                                           .
                                           .
     Kth level                             .
                                          |_|      1 = N/2^k


                                                     N=2^k

                                                   log(N) = log(2^k)

                                                   logN   = kLog2

                                                   k   =logN/klog2   = log2N

               Total comparison in the worst case = logN

   search in  1lacks elemenys

  Linear                              binary search

1 lacks comparison                      20 comparison       (log2(100000)


        O(N)                                O(log N)

    
-----------------------------------------------------------------------------------------------------

Binary search
--------------

public class Main{
    public static void main(String[] args)
    {
        int arr[]={1,2,3,4,5,6,7};
        int target =7;
        int ans = binarySearch(arr,target);
        System.out.println(ans);

    }
    static  int binarySearch(int[] arr ,int target)
    {
        int s=0;
        int e=arr.length-1;
        int mid;
        while(s<=e)
        {
            mid=s+(e-s)/2;   // efficient way //might be possible that (s+e) exceeds the range of intin java exceeds some error
             if(arr[mid]>target)
                {
                    e=mid-1;
                }
                else if(arr[mid]<target){
                    s=mid+1;         
                }
               else
                 return mid;
        }



      (s+e)/2  =  s+(e-s)/2



Orger-Agnostic Binary Search
_______________________________


 its for both asc and desc 

               

public class Main{
    public static void main(String[] args)
    {
        int arr[]={1,2,3,4,5,6,7};
        int target =7;
        int ans = binarySearch(arr,target);
        System.out.println(ans);

    }
    static  int binarySearch(int[] arr ,int target)
    {
        int s=0;
        int e=arr.length-1;
        boolean  isAsc = arr[s]<arr[e];
        int mid;
        while(s<=e)
        {
            mid=s+(e-s)/2;   // efficient way
            if(arr[mid]==target)
            {
                return  mid;
            }
            else if(isAsc)
            {
                if(arr[mid]>target)
                {
                    e=mid-1;
                }
                else{
                    s=mid+1;
                }
            }
            else {

                if(arr[mid]<target)
                {
                    e=mid-1;
                }
                else{
                    s=mid+1;
                }
            }

        }
        return -1;

    }
}

import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] arr = {7, 8, 8, 8, 8, 9, 10};
        int target = 6;
        int result[] = {-1, -1};
        result[0] = position(arr, target, true);

        result[1] = position(arr, target, false);
        System.out.println(Arrays.toString(result));
    }

    static int position(int[] arr, int target, boolean startIndex) {
        int l = 0;
        int r = arr.length - 1;
        int mid;
        int ans = -1;
        while (l <= r)
        {
            mid = l + (r - l) / 2;

            if (arr[mid] > target) {
                r = mid - 1;
            } else if (arr[mid] < target) {
                l = mid + 1;
            } else {
                ans = mid;
                if (startIndex) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }



        }
        return ans;
    }
}