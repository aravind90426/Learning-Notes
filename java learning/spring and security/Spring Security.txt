Spring Security

-> Spring Security is a framework in the Spring ecosystem that helps secure your Java/Spring applications.
-> It mainly does two things:

    Authentication → Verify "Nee yaar?"

Example: Username & password check while login.

Authorization → Check "Nee inga vara permission iruka?"  

Example: Admin page access only for ADMIN users.


Authentication and Authorization


1. Authentication ("Who are you?")

      ->Authentication is the process of verifying a user's identity.
     ->It ensures that the person or system trying to access a resource is who they claim to be.
      ->It is usually done using:	
		Username & Password
		OTP (One-Time Password)
		Biometric data (Fingerprint, Face ID)
		Social login (Google, Facebook)
👉 Example: When you log in to a website with your username and password, the system checks if your credentials match those in the database.


2. Authorization ("What are you allowed to do?")

	->Authorization determines what actions a user is permitted to perform after authentication.
	->It controls access to resources based on roles or permissions					.
	->It is implemented using:
		Role-based access control (RBAC) (e.g., Admin, User, Guest)
		Access control lists (ACL)
		Token-based permissions (JWT, OAuth)
👉 Example: After logging in to a system, an admin might have access to user management, but a regular user can only view their profile.

Ke

Authentication = Showing your ID card to enter a building.
Authorization = Being allowed to enter specific rooms inside the building based on your role.










   Session

                    login/hello

Clients     ------------------------->                server


 	 <-----------------------------

                Session Id



1️⃣ Client Sends a Request (No Session Yet)

		
2️⃣ Server Creates a New Session
	The server checks if the request has a JSESSIONID cookie.
	If no session ID is found, the server:
		Creates a new HttpSession (request.getSession(true))
		Generates a unique Session ID (e.g., ABC123XYZ)
		Stores the session on the server (in memory or database).

3️⃣ Server Sends the Session ID in the Response
	The server sends a Set-Cookie header with the session ID:
        The client (browser) stores this session ID in cookies.


4️⃣ Client Sends Session ID in Future Requests
	Next time the client sends a request, it includes the session ID in the Cookie header
        The server reads the session ID and retrieves user data.

5️⃣ Server Recognizes the User and Responds

            Since the session ID is valid, the server identifies the user and responds with the requested data.




🍪 What is a Cookie?
A cookie is a small piece of data that a server sends to a client's browser. The browser stores it and sends it back with future requests to the same server.

Cookies are mainly used for session management, authentication, tracking user preferences, and personalization.
___________________________________________________________________________________________________________________________________________________

                                               server


client ------------------>       f1
				|
  				f2             dispactch servelet ----->s1
 				|
 				f3					s2...
				|
 				f4







Explanation of the Flow:
1️⃣ Client Sends Request

	A user (browser/Postman) sends a request (e.g., GET /api/hello).


2️⃣ Spring Security Intercepts Request (Servlet Filters)

	The request first goes through Spring Security’s filter chain (DelegatingFilterProxy).
	Filters like BasicAuthenticationFilter check if the user is authenticated.


3️⃣ Authentication and Authorization Checks

	If authentication is required, it checks with AuthenticationManager and UserDetailsService.
	if authorization is needed, it verifies roles/permissions.

4️⃣ Request Proceeds to DispatcherServlet

	If authentication and authorization pass, the request reaches Spring MVC’s DispatcherServlet, which calls the controller.

5️⃣ Response is Sent Back to Client

	The controller processes the request and returns a response, which passes back through Spring Security and is sent to the client.





SecurityFilterChain
______________

  -> In Spring Security, every incoming request passes through a chain of filters before it reaches your controller.

  -> These filters check authentication & authorization and apply other security features.

   -> The SecurityFilterChain bean is where you define your security rules (which URLs need login, which are public, what roles are required, etc.).


   spring give default filter for configuration

EG)
___

. SecurityFilterChain (Spring Security layer)

First stop: Security Filter Chain 🛡️

Checks:

    -> Is this request allowed without login? (permitAll())

    -> If login needed → Is the user authenticated?

    -> If authenticated → Does the user have the right role?

    -> If pass → request goes to the DispatcherServlet.

    -> If fail → returns Access Denied or redirects to login.



3. DispatcherServlet (Spring MVC layer)
--------------------

  -> Acts as Front Controller.

  -> Finds the right controller method using HandlerMapping.


----------------------------------------------------------------------------------------------------------------------------

Spring Security – Default Behaviour
_____________________________________

 1) Authentication Required for All Requests

        By default, every HTTP request needs authentication.

 2) Auto-Generated Login Form
  
        If you haven’t created your own login page, Spring Security provides a basic form at /login.

 3) Default User

        Username: user

        Password: Randomly generated (printed in console).

  -> You can change these via application.properties:

        spring.security.user.name=admin
        spring.security.user.password=1234

4. Session-based authentication

    -> Once you log in, Spring Security stores your authentication in an HTTP session.

    -> You don’t need to log in again for each request until the session expires or you log out.

5) Logout endpoint

    -> By default, /logout is enabled.

    -> Sending a POST request to /logout will:

           Invalidate the session

           Clear authentication
  
          Redirect you to the login page

6. CSRF Protection enabled

    -> CSRF (Cross-Site Request Forgery) protection is ON for non-GET requests (POST, PUT, DELETE).

    -> This means if you try to POST from tools like Postman without sending the CSRF token, it will fail unless CSRF is disabled.

7. Password stored in memory (default)

    -> The default user/password are kept in memory (no database involved) unless you configure UserDetailsService.

__________________________________________________________________________________________________________________________________________________

When We Need Manual Configuration
------------------------------

  If you want to:

       -> Allow some endpoints without authentication

       -> Change login form page

        -> Use JWT instead of session login

        -> Disable CSRF for APIs

        -> Add role-based access control

👉 Then you override the default config by creating a configuration file




@Configuration
@EnableWebSecurity // Enables Spring Security's web security support
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
            // ==================== AUTHORIZATION RULES ====================
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll() // Public endpoints: no login needed
                .requestMatchers("/admin/**").hasRole("ADMIN") // Only ADMIN can access
                .anyRequest().authenticated() // All other URLs require login
            )

            // ==================== FORM LOGIN ====================
            .formLogin(form -> form
                .loginPage("/login")               // Your custom login page URL
                .loginProcessingUrl("/process-login") // Form action URL where Spring Security will process credentials
                .usernameParameter("username")     // Name of the username field in the login form
                .passwordParameter("password")     // Name of the password field in the login form
                .defaultSuccessUrl("/home", true)  // Redirect here after successful login (true = always redirect here)
                .failureUrl("/login?error=true")   // Redirect if login fails
                .permitAll()                       // Allow everyone to see the login page
            )

            // ==================== LOGOUT ====================
            .logout(logout -> logout
                .logoutUrl("/logout")              // URL to trigger logout
                .logoutSuccessUrl("/login?logout") // Redirect after logout
                .invalidateHttpSession(true)       // Clear the session
                .deleteCookies("JSESSIONID")       // Delete cookies
                .permitAll()
            )

            // ==================== CSRF PROTECTION ====================
            .csrf(csrf -> csrf.disable()); // ❗ Disable only for APIs / testing (default is enabled for web forms)

        return http.build();  // object ha uild panni retun pannum 
    }
}



4. Why SecurityFilterChain?

  -> Spring Security uses filters to process security logic (authentication, authorization, etc.).

  -> All these filters form a filter chain.

  -> SecurityFilterChain is where we tell Spring which requests are allowed, denied, or redirected.

  -> By defining our own SecurityFilterChain bean, we replace or add to the default filter chain rules.




        [ HTTP Request ]
               |
               v
 ┌──────────────────────────────────────┐
 │ Servlet Container (Tomcat, etc.)     │
 └──────────────────────────────────────┘
               |
               v
 ┌──────────────────────────────────────┐
 │ Spring Security FilterChainProxy      │
 │  ┌────────────────────────────────┐  │
 │  │ SecurityFilterChain ( /admin/** ) │
 │  │  - Auth checks                  │  │
 │  │  - Role checks                  │  │
 │  │  - CSRF checks                  │  │
 │  └────────────────────────────────┘  │
 └──────────────────────────────────────┘
               |
               v
 ┌──────────────────────────────────────┐
 │ DispatcherServlet (Spring MVC)        │
 │   - HandlerMapping → Controller       │
 │   - ViewResolver / JSON Output        │
 └──────────────────────────────────────┘
               |
               v
        [ HTTP Response ]


_______________________________________________________________________________________________________________________


Task 1)   Try hello world program - it shows login page default  

     -> pass word is generated ans show  in intelij


  for logout



http://localhost:8080/logout




    it follows above standard   if you want session id



code :


@RestController
public class Controller {
    @GetMapping("/")
    public String index(HttpServletRequest req)
    {
        return "Hello world  "  + req.getSession().getId();
    }
}


___________________________________________________________________________________________________________________


if you want set password 

   this type can allow only one user . multiple user can learn in future


-> resources / application properties



spring.security.user.name = aravind
spring.security.user.password = 123






Note:

owaps  Top 10            -- helps to find which are the attack possible to our self




____________________________________________________________________________________________________________________________________________________________________________________________________________________________


CSRF (Cross Site Request  Forfery)  - Security filter chain


					Sever			
				_______________________________________
				|
				|				c1
				|    f1
				|
client -------------------->    |     f2               fc        c2
				|
				|
                                |    f3                          c3
				|
				_________________________________________



fc - front controller- dispatchservler
_c1 -c2-c3  - controller sevice repository


f1-f2-f3    are filter



one of the filter --  CSRF
______________________________________________________________________________________________________________________________________________________





                  req
      client --------------> server

            <----------------


     sessionId                                 




attacker sent the link some one access that the session id can got by attacker -> thy use anything

 -> avoid this we use CRSF

-> default ta csrf assign





Speing Security
______________

http

   -> get
   
   -> post         |
                   |    
    -> put         |
		   |   --->  Critical method csrf enabled
    -> Delete      |






package com.example.springSecurity.controller;

import com.example.springSecurity.model.Student;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@RestController
public class StudentController {

    List<Student> list = new ArrayList<>(Arrays.asList(new Student(1,"aravind","CT"),
            new Student(2,"sarjun","AI"),
            new Student(3,"arun","CY")
            ));

    @GetMapping("students")
    public List<Student> getStudents()
    {
        return list;
    }

    @PostMapping("students")
    public String addStudent(@RequestBody Student student)
    {
        list.add(student);
        return "Added";
    }

     @GetMapping("csrf")
    public CsrfToken getCsrfToken(HttpServletRequest request)
    {
        return (CsrfToken) request.getAttribute("_csrf");
    }


}





  namma naala direct ta anupa mudiyaathu so we need crsf token and put header in post req





______________________________________________________________________________________________________________________________________________________

Manual Configuration  tell string to stop



// these helps to hei spring u stop default security i can manually take for that.
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http.build();//   give security filtre chain option
    }
}


mrun without loggin page




_____________________________________________________________________________________________________________________________________



  1. CSRF Disable

		Same site Strict
		Session Stateless

  //prerequest functionl Interface and Lambda expression


    http.csrf(customizer -> customizer.disable());   // disable csrf



resources means 

localhost:8080/
localhost:8080/students

 theses all are we can switch resources simentansuoly cookies can share .
but payment ku cookies share aava koodathu so we use Same site Strict

go app properites

add this

//**
  server.servlet.session.cookie.same-site=strict
//

it helps to other outside resources ku csrf anupaathu . it helps to avoid csrf attck


//**
http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit 




package com.example.springSecurity.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;


// these helps to hei spring u stop default security i can manually take for that.



@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(customizer -> customizer.disable());   // disable csrf
        http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit
        http.formLogin(Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());   // it helps to other client like postman to acesss

        //stateless - oru oru time mu new session id generate pannum
        http.sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();//   give security filtre chain option
    }
}

but we have a problem it shows every refresh login.
in the case we avoid 
http.formLogin(Customizer.withDefaults());
  remove that . 




______________________________________________________________________________________

Multiple User in Spring Boot



 user la verify panna we use UserDetailsService - Interface

 InMemoryUserDetailManager  class  gives object for the interface

the class Con structor needs  UserDetail

UserDetail needs User




package com.example.springSecurity.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

import java.util.List;


// these helps to hei spring u stop default security i can manually take for that.
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(customizer -> customizer.disable());   // disable csrf
        http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit
        //http.formLogin(Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());   // it helps to other client like postman to acesss

        //stateless - oru oru time mu new session id generate pannum
        http.sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();//   give security filtre chain option
    }


    @Bean
    public UserDetailsService userDetailsService(){

        UserDetails user1 = User.withDefaultPasswordEncoder()
                .username("arun")
                .password("1234")
                .roles("ADMIN")
                .build();

        UserDetails user2 = User.withDefaultPasswordEncoder()
                .username("vijay")
                .password("1234")
                .roles("ADMIN")
                .build();

        UserDetails user3 = User.withDefaultPasswordEncoder()
                .username("hari")
                .password("1234")
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(user1,user2,user3); //varagas
    }
}



in configuration class

______________________________________________________________________________________________________________________

verifying user from DB
___________________





normal user name and psword  are ----> Unauthenticated object    // its stores like objecr



				_____________________________
Unauthenticated object --------> |  Authenticator Provider  |-----------> authenticated object 
				 |__________________________|





configuration file
----------------

@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture
    @Autowired
    UserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(customizer -> customizer.disable());   // disable csrf
        http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit
        //http.formLogin(Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());   // it helps to other client like postman to acesss

        //stateless - oru oru time mu new session id generate pannum
        http.sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();//   give security filtre chain option
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();  // intract with db
        provider.setPasswordEncoder(NoOpPasswordEncoder.getInstance());  // now we not encoe password
        provider.setUserDetailsService(userDetailsService); // we give UserDetailsService object in it so we create class
        return  provider;
    }


}


controller
-----------     - after logine


@RestController
public class Controller {
    @GetMapping("/")
    public String index(HttpServletRequest req)
    {
        return "Hello world  "  + req.getSession().getId();
    }
}

dao
------

public interface UserDetailRepo extends JpaRepository<Users,Integer> {


    Users findByUsername(String username);

}


sevice
-------

@Service
public class MyUserDetailService implements UserDetailsService {

    @Autowired
    UserDetailRepo userDetailRepo;



    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        Users user = userDetailRepo.findByUsername(username);     // calling repo to get user
        if (user == null) {
            System.out.println("User NOT Found!");
            throw new UsernameNotFoundException("Username NOT Found");
        }



        return new UserPrinciple(user);     - we rturn in form of UserDetails -
    }

}

   we rturn in form of UserDetails - it is an interface so we create class as userprinciple 



package com.example.springSecurity.model;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

public class UserPrinciple implements UserDetails {

    private  Users users;
    public UserPrinciple(Users users) {
        this.users = users;
    }



    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singleton(new SimpleGrantedAuthority("USER"));
    }

    @Override
    public String getPassword() {
        return users.getPassword();
    }

    @Override
    public String getUsername() {
        return users.getUsername();
    }


}



just implement pannale itnatha methods la vanthurum





Model

-> no - arg constructor must -- athunaala 1 day error solve pannite irunthen




@Entity
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password;

    // No-arg constructor required by Hibernate
    public Users() {}

    // Parameterized constructor
    public Users(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
 



unauthenticated object --------> |  Authenticator Provider  |-----------> authenticated object 


                                      |
				      | ->  userDetailSevice theva -- interface -  naama oru class create panni implement pannuvom
											|
								________________________|
           							|-> loadbyusername nu oru method athula irukku athuku  
									UserDetail theva
													
            								| - nama kitta veru users mattum tha irukku athunaala seperte class implement 
										panni crete pannuvom




_____________________________________________________________________________________________________________________________________________________________________

                             JWT WEB TOKEN


1. JWT-na enna?

  -> JWT is like a digital visiting card.

  -> Namma user login pannumbothu, server namakku oru token kudukkum.

  -> Andha token la namma identity (email/username) & some info store pannirukkum, but encrypted/secure form la.

  -> Adha use pannitu next time server kita “naan already login pannirukken” nu prove panna mudiyum



1. User → Auth Controller

  ->User sends a POST request to /auth/login with username & password.

Example:

{
  "username": "aravind",
  "password": "12345"
}

2. Auth Controller → Authentication Manager

  -> AuthController receives the login request.

  -> It calls AuthenticationManager to check whether the username/password is correct.

  -> AuthenticationManager → internally uses DAO Authentication Provider.

3. DAO Authentication Provider → Database Check

  -> DAO (Data Access Object) Authentication Provider will:

  -> Fetch user details from DB (via UserDetailsService).

  -> Compare the submitted password with the stored password (usually hashed).

  -> If correct → it returns an Authentication object (which contains username, roles, etc.).

4. Authentication Manager → JWT Util

  -> Once authentication is successful, the AuthController will ask JWT Util to generate a JWT token.

JWT Util does:

  -> Takes authenticated user details (username & roles).

  ->Signs the token using a secret key.

  ->Sets expiry time (example: 1 hour).

5. JWT Token → User

The AuthController sends the generated token back to the user as a response.

The user stores this token (in localStorage, cookies, or mobile app memory).

Next Requests (Not shown fully in diagram)

User sends the token in the Authorization header:

Authorization: Bearer <jwt_token>


A JWT filter checks this token for every request.

If valid → allows access to protected APIs.

💡 Key points in this diagram:

AuthenticationManager → checks credentials.

DAO Auth Provider → interacts with DB and verifies password.

JWT Util → creates token.

AuthController → acts like the main coordinator.