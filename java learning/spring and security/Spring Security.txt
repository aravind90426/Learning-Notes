Spring Security

-> Spring Security is a framework in the Spring ecosystem that helps secure your Java/Spring applications.
-> It mainly does two things:

    Authentication â†’ Verify "Nee yaar?"

Example: Username & password check while login.

Authorization â†’ Check "Nee inga vara permission iruka?"  

Example: Admin page access only for ADMIN users.


Authentication and Authorization


1. Authentication ("Who are you?")

      ->Authentication is the process of verifying a user's identity.
     ->It ensures that the person or system trying to access a resource is who they claim to be.
      ->It is usually done using:	
		Username & Password
		OTP (One-Time Password)
		Biometric data (Fingerprint, Face ID)
		Social login (Google, Facebook)
ðŸ‘‰ Example: When you log in to a website with your username and password, the system checks if your credentials match those in the database.


2. Authorization ("What are you allowed to do?")

	->Authorization determines what actions a user is permitted to perform after authentication.
	->It controls access to resources based on roles or permissions					.
	->It is implemented using:
		Role-based access control (RBAC) (e.g., Admin, User, Guest)
		Access control lists (ACL)
		Token-based permissions (JWT, OAuth)
ðŸ‘‰ Example: After logging in to a system, an admin might have access to user management, but a regular user can only view their profile.

Ke

Authentication = Showing your ID card to enter a building.
Authorization = Being allowed to enter specific rooms inside the building based on your role.










   Session

                    login/hello

Clients     ------------------------->                server


 	 <-----------------------------

                Session Id



1ï¸âƒ£ Client Sends a Request (No Session Yet)

		
2ï¸âƒ£ Server Creates a New Session
	The server checks if the request has a JSESSIONID cookie.
	If no session ID is found, the server:
		Creates a new HttpSession (request.getSession(true))
		Generates a unique Session ID (e.g., ABC123XYZ)
		Stores the session on the server (in memory or database).

3ï¸âƒ£ Server Sends the Session ID in the Response
	The server sends a Set-Cookie header with the session ID:
        The client (browser) stores this session ID in cookies.


4ï¸âƒ£ Client Sends Session ID in Future Requests
	Next time the client sends a request, it includes the session ID in the Cookie header
        The server reads the session ID and retrieves user data.

5ï¸âƒ£ Server Recognizes the User and Responds

            Since the session ID is valid, the server identifies the user and responds with the requested data.




ðŸª What is a Cookie?
A cookie is a small piece of data that a server sends to a client's browser. The browser stores it and sends it back with future requests to the same server.

Cookies are mainly used for session management, authentication, tracking user preferences, and personalization.
___________________________________________________________________________________________________________________________________________________

                                               server


client ------------------>       f1
				|
  				f2             dispactch servelet ----->s1
 				|
 				f3					s2...
				|
 				f4







Explanation of the Flow:
1ï¸âƒ£ Client Sends Request

	A user (browser/Postman) sends a request (e.g., GET /api/hello).


2ï¸âƒ£ Spring Security Intercepts Request (Servlet Filters)

	The request first goes through Spring Securityâ€™s filter chain (DelegatingFilterProxy).
	Filters like BasicAuthenticationFilter check if the user is authenticated.


3ï¸âƒ£ Authentication and Authorization Checks

	If authentication is required, it checks with AuthenticationManager and UserDetailsService.
	if authorization is needed, it verifies roles/permissions.

4ï¸âƒ£ Request Proceeds to DispatcherServlet

	If authentication and authorization pass, the request reaches Spring MVCâ€™s DispatcherServlet, which calls the controller.

5ï¸âƒ£ Response is Sent Back to Client

	The controller processes the request and returns a response, which passes back through Spring Security and is sent to the client.





SecurityFilterChain
______________

  -> In Spring Security, every incoming request passes through a chain of filters before it reaches your controller.

  -> These filters check authentication & authorization and apply other security features.

   -> The SecurityFilterChain bean is where you define your security rules (which URLs need login, which are public, what roles are required, etc.).


   spring give default filter for configuration

EG)
___

. SecurityFilterChain (Spring Security layer)

First stop: Security Filter Chain ðŸ›¡ï¸

Checks:

    -> Is this request allowed without login? (permitAll())

    -> If login needed â†’ Is the user authenticated?

    -> If authenticated â†’ Does the user have the right role?

    -> If pass â†’ request goes to the DispatcherServlet.

    -> If fail â†’ returns Access Denied or redirects to login.



3. DispatcherServlet (Spring MVC layer)
--------------------

  -> Acts as Front Controller.

  -> Finds the right controller method using HandlerMapping.


----------------------------------------------------------------------------------------------------------------------------

Spring Security â€“ Default Behaviour
_____________________________________

 1) Authentication Required for All Requests

        By default, every HTTP request needs authentication.

 2) Auto-Generated Login Form
  
        If you havenâ€™t created your own login page, Spring Security provides a basic form at /login.

 3) Default User

        Username: user

        Password: Randomly generated (printed in console).

  -> You can change these via application.properties:

        spring.security.user.name=admin
        spring.security.user.password=1234

4. Session-based authentication

    -> Once you log in, Spring Security stores your authentication in an HTTP session.

    -> You donâ€™t need to log in again for each request until the session expires or you log out.

5) Logout endpoint

    -> By default, /logout is enabled.

    -> Sending a POST request to /logout will:

           Invalidate the session

           Clear authentication
  
          Redirect you to the login page

6. CSRF Protection enabled

    -> CSRF (Cross-Site Request Forgery) protection is ON for non-GET requests (POST, PUT, DELETE).

    -> This means if you try to POST from tools like Postman without sending the CSRF token, it will fail unless CSRF is disabled.

7. Password stored in memory (default)

    -> The default user/password are kept in memory (no database involved) unless you configure UserDetailsService.

__________________________________________________________________________________________________________________________________________________

When We Need Manual Configuration
------------------------------

  If you want to:

       -> Allow some endpoints without authentication

       -> Change login form page

        -> Use JWT instead of session login

        -> Disable CSRF for APIs

        -> Add role-based access control

ðŸ‘‰ Then you override the default config by creating a configuration file




@Configuration
@EnableWebSecurity // Enables Spring Security's web security support
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
            // ==================== AUTHORIZATION RULES ====================
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll() // Public endpoints: no login needed
                .requestMatchers("/admin/**").hasRole("ADMIN") // Only ADMIN can access
                .anyRequest().authenticated() // All other URLs require login
            )

            // ==================== FORM LOGIN ====================
            .formLogin(form -> form
                .loginPage("/login")               // Your custom login page URL
                .loginProcessingUrl("/process-login") // Form action URL where Spring Security will process credentials
                .usernameParameter("username")     // Name of the username field in the login form
                .passwordParameter("password")     // Name of the password field in the login form
                .defaultSuccessUrl("/home", true)  // Redirect here after successful login (true = always redirect here)
                .failureUrl("/login?error=true")   // Redirect if login fails
                .permitAll()                       // Allow everyone to see the login page
            )

            // ==================== LOGOUT ====================
            .logout(logout -> logout
                .logoutUrl("/logout")              // URL to trigger logout
                .logoutSuccessUrl("/login?logout") // Redirect after logout
                .invalidateHttpSession(true)       // Clear the session
                .deleteCookies("JSESSIONID")       // Delete cookies
                .permitAll()
            )

            // ==================== CSRF PROTECTION ====================
            .csrf(csrf -> csrf.disable()); // â— Disable only for APIs / testing (default is enabled for web forms)

        return http.build();  // object ha uild panni retun pannum 
    }
}



4. Why SecurityFilterChain?

  -> Spring Security uses filters to process security logic (authentication, authorization, etc.).

  -> All these filters form a filter chain.

  -> SecurityFilterChain is where we tell Spring which requests are allowed, denied, or redirected.

  -> By defining our own SecurityFilterChain bean, we replace or add to the default filter chain rules.




        [ HTTP Request ]
               |
               v
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Servlet Container (Tomcat, etc.)     â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               |
               v
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Spring Security FilterChainProxy      â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 â”‚  â”‚ SecurityFilterChain ( /admin/** ) â”‚
 â”‚  â”‚  - Auth checks                  â”‚  â”‚
 â”‚  â”‚  - Role checks                  â”‚  â”‚
 â”‚  â”‚  - CSRF checks                  â”‚  â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               |
               v
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ DispatcherServlet (Spring MVC)        â”‚
 â”‚   - HandlerMapping â†’ Controller       â”‚
 â”‚   - ViewResolver / JSON Output        â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               |
               v
        [ HTTP Response ]


_______________________________________________________________________________________________________________________


Task 1)   Try hello world program - it shows login page default  

     -> pass word is generated ans show  in intelij


  for logout



http://localhost:8080/logout




    it follows above standard   if you want session id



code :


@RestController
public class Controller {
    @GetMapping("/")
    public String index(HttpServletRequest req)
    {
        return "Hello world  "  + req.getSession().getId();
    }
}


___________________________________________________________________________________________________________________


if you want set password 

   this type can allow only one user . multiple user can learn in future


-> resources / application properties



spring.security.user.name = aravind
spring.security.user.password = 123






Note:

owaps  Top 10            -- helps to find which are the attack possible to our self




____________________________________________________________________________________________________________________________________________________________________________________________________________________________


CSRF (Cross Site Request  Forfery)  - Security filter chain


					Sever			
				_______________________________________
				|
				|				c1
				|    f1
				|
client -------------------->    |     f2               fc        c2
				|
				|
                                |    f3                          c3
				|
				_________________________________________



fc - front controller- dispatchservler
_c1 -c2-c3  - controller sevice repository


f1-f2-f3    are filter



one of the filter --  CSRF
______________________________________________________________________________________________________________________________________________________





                  req
      client --------------> server

            <----------------


     sessionId                                 




attacker sent the link some one access that the session id can got by attacker -> thy use anything

 -> avoid this we use CRSF

-> default ta csrf assign





Speing Security
______________

http

   -> get
   
   -> post         |
                   |    
    -> put         |
		   |   --->  Critical method csrf enabled
    -> Delete      |






package com.example.springSecurity.controller;

import com.example.springSecurity.model.Student;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@RestController
public class StudentController {

    List<Student> list = new ArrayList<>(Arrays.asList(new Student(1,"aravind","CT"),
            new Student(2,"sarjun","AI"),
            new Student(3,"arun","CY")
            ));

    @GetMapping("students")
    public List<Student> getStudents()
    {
        return list;
    }

    @PostMapping("students")
    public String addStudent(@RequestBody Student student)
    {
        list.add(student);
        return "Added";
    }

     @GetMapping("csrf")
    public CsrfToken getCsrfToken(HttpServletRequest request)
    {
        return (CsrfToken) request.getAttribute("_csrf");
    }


}





  namma naala direct ta anupa mudiyaathu so we need crsf token and put header in post req





______________________________________________________________________________________________________________________________________________________

Manual Configuration  tell string to stop



// these helps to hei spring u stop default security i can manually take for that.
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http.build();//   give security filtre chain option
    }
}


mrun without loggin page




_____________________________________________________________________________________________________________________________________



  1. CSRF Disable

		Same site Strict
		Session Stateless

  //prerequest functionl Interface and Lambda expression


    http.csrf(customizer -> customizer.disable());   // disable csrf



resources means 

localhost:8080/
localhost:8080/students

 theses all are we can switch resources simentansuoly cookies can share .
but payment ku cookies share aava koodathu so we use Same site Strict

go app properites

add this

//**
  server.servlet.session.cookie.same-site=strict
//

it helps to other outside resources ku csrf anupaathu . it helps to avoid csrf attck


//**
http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit 




package com.example.springSecurity.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;


// these helps to hei spring u stop default security i can manually take for that.



@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(customizer -> customizer.disable());   // disable csrf
        http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit
        http.formLogin(Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());   // it helps to other client like postman to acesss

        //stateless - oru oru time mu new session id generate pannum
        http.sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();//   give security filtre chain option
    }
}

but we have a problem it shows every refresh login.
in the case we avoid 
http.formLogin(Customizer.withDefaults());
  remove that . 




______________________________________________________________________________________

Multiple User in Spring Boot



 user la verify panna we use UserDetailsService - Interface

 InMemoryUserDetailManager  class  gives object for the interface

the class Con structor needs  UserDetail

UserDetail needs User




package com.example.springSecurity.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

import java.util.List;


// these helps to hei spring u stop default security i can manually take for that.
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(customizer -> customizer.disable());   // disable csrf
        http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit
        //http.formLogin(Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());   // it helps to other client like postman to acesss

        //stateless - oru oru time mu new session id generate pannum
        http.sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();//   give security filtre chain option
    }


    @Bean
    public UserDetailsService userDetailsService(){

        UserDetails user1 = User.withDefaultPasswordEncoder()
                .username("arun")
                .password("1234")
                .roles("ADMIN")
                .build();

        UserDetails user2 = User.withDefaultPasswordEncoder()
                .username("vijay")
                .password("1234")
                .roles("ADMIN")
                .build();

        UserDetails user3 = User.withDefaultPasswordEncoder()
                .username("hari")
                .password("1234")
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(user1,user2,user3); //varagas
    }
}



in configuration class

______________________________________________________________________________________________________________________

verifying user from DB
___________________





normal user name and psword  are ----> Unauthenticated object    // its stores like objecr



				_____________________________
Unauthenticated object --------> |  Authenticator Provider  |-----------> authenticated object 
				 |__________________________|





configuration file
----------------

@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    // we configure SecurtyFilture
    @Autowired
    UserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(customizer -> customizer.disable());   // disable csrf
        http.authorizeHttpRequests(request-> request.anyRequest().authenticated());// it helps to witthout login no one can permit
        //http.formLogin(Customizer.withDefaults());
        http.httpBasic(Customizer.withDefaults());   // it helps to other client like postman to acesss

        //stateless - oru oru time mu new session id generate pannum
        http.sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();//   give security filtre chain option
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();  // intract with db
        provider.setPasswordEncoder(NoOpPasswordEncoder.getInstance());  // now we not encoe password
        provider.setUserDetailsService(userDetailsService); // we give UserDetailsService object in it so we create class
        return  provider;
    }


}


controller
-----------     - after logine


@RestController
public class Controller {
    @GetMapping("/")
    public String index(HttpServletRequest req)
    {
        return "Hello world  "  + req.getSession().getId();
    }
}

dao
------

public interface UserDetailRepo extends JpaRepository<Users,Integer> {


    Users findByUsername(String username);

}


sevice
-------

@Service
public class MyUserDetailService implements UserDetailsService {

    @Autowired
    UserDetailRepo userDetailRepo;



    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        Users user = userDetailRepo.findByUsername(username);     // calling repo to get user
        if (user == null) {
            System.out.println("User NOT Found!");
            throw new UsernameNotFoundException("Username NOT Found");
        }



        return new UserPrinciple(user);     - we rturn in form of UserDetails -
    }

}

   we rturn in form of UserDetails - it is an interface so we create class as userprinciple 



package com.example.springSecurity.model;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

public class UserPrinciple implements UserDetails {

    private  Users users;
    public UserPrinciple(Users users) {
        this.users = users;
    }



    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singleton(new SimpleGrantedAuthority("USER"));
    }

    @Override
    public String getPassword() {
        return users.getPassword();
    }

    @Override
    public String getUsername() {
        return users.getUsername();
    }


}



just implement pannale itnatha methods la vanthurum





Model

-> no - arg constructor must -- athunaala 1 day error solve pannite irunthen




@Entity
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password;

    // No-arg constructor required by Hibernate
    public Users() {}

    // Parameterized constructor
    public Users(String username, String password) {
        this.username = username;
        this.password = password;
    }
}
 



unauthenticated object --------> |  Authenticator Provider  |-----------> authenticated object 


                                      |
				      | ->  userDetailSevice theva -- interface -  naama oru class create panni implement pannuvom
											|
								________________________|
           							|-> loadbyusername nu oru method athula irukku athuku  
									UserDetail theva
													
            								| - nama kitta veru users mattum tha irukku athunaala seperte class implement 
										panni crete pannuvom




_____________________________________________________________________________________________________________________________________________________________________

                             JWT WEB TOKEN


1. JWT-na enna?

  -> JWT is like a digital visiting card.

  -> Namma user login pannumbothu, server namakku oru token kudukkum.

  -> Andha token la namma identity (email/username) & some info store pannirukkum, but encrypted/secure form la.

  -> Adha use pannitu next time server kita â€œnaan already login pannirukkenâ€ nu prove panna mudiyum



1. User â†’ Auth Controller

  ->User sends a POST request to /auth/login with username & password.

Example:

{
  "username": "aravind",
  "password": "12345"
}

2. Auth Controller â†’ Authentication Manager

  -> AuthController receives the login request.

  -> It calls AuthenticationManager to check whether the username/password is correct.

  -> AuthenticationManager â†’ internally uses DAO Authentication Provider.

3. DAO Authentication Provider â†’ Database Check

  -> DAO (Data Access Object) Authentication Provider will:

  -> Fetch user details from DB (via UserDetailsService).

  -> Compare the submitted password with the stored password (usually hashed).

  -> If correct â†’ it returns an Authentication object (which contains username, roles, etc.).

4. Authentication Manager â†’ JWT Util

  -> Once authentication is successful, the AuthController will ask JWT Util to generate a JWT token.

JWT Util does:

  -> Takes authenticated user details (username & roles).

  ->Signs the token using a secret key.

  ->Sets expiry time (example: 1 hour).

5. JWT Token â†’ User

The AuthController sends the generated token back to the user as a response.

The user stores this token (in localStorage, cookies, or mobile app memory).

Next Requests (Not shown fully in diagram)

User sends the token in the Authorization header:

Authorization: Bearer <jwt_token>


A JWT filter checks this token for every request.

If valid â†’ allows access to protected APIs.

ðŸ’¡ Key points in this diagram:

AuthenticationManager â†’ checks credentials.

DAO Auth Provider â†’ interacts with DB and verifies password.

JWT Util â†’ creates token.

AuthController â†’ acts like the main coordinator.